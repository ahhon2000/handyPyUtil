#!/usr/bin/python3
try:from pathlib import Path as P;R=P.resolve;E=P.exists; F = R(P(__file__));\
    L = lambda p: p / 'cfg.py'; from handyPyUtil import A; exec(A)
except: O=open(R(next(filter(E,map(L,F.parents))))); exec(O.read()); O.close()

from . import TestKitDB
from ..Database import DBTYPES
from .. import Database_mysql, Database_mysql

def populate(q, tk):
    q / f"""
        CREATE TABLE vegetables (
            id INT PRIMARY KEY AUTO_INCREMENT,
            name VARCHAR(32) NOT NULL
        )
    """

    q / f"""
        INSERT INTO vegetables (name) VALUES
        ('potatoes'), ('tomatoes'), ('carrots')
    """

def general(q, tk):
    rs = q / "SELECT 138 AS x"
    assert next(rs)['x'] == 138

    r = q(0) / "SELECT 148 AS y"
    assert r['y'] == 148

    rs = q(aslist=True) / "SELECT NULL AS x"
    assert rs[0]['x'] is None

    n = q(0, name='potatoes') / """
        SELECT * FROM vegetables WHERE name=%(name)s
    """
    assert n['name'] == 'potatoes', f"n = {n}"

def placeholders(q, tk):
    # check positional placeholders

    r = "SELECT name FROM vegetables WHERE name != %s and name != %s"

    # syntax v. 1
    rs = q / ['carrots', 'tomatoes'] / r
    assert next(rs)['name'] == 'potatoes'

    # syntax v. 2
    rs = q(('carrots', 'tomatoes')) / r
    assert next(rs)['name'] == 'potatoes'

    # syntax v. 3
    rs = q / q(['carrots', 'tomatoes']) / r
    assert next(rs)['name'] == 'potatoes'

    # syntax v. 4
    rs = q * 'carrots' * 'tomatoes' / r
    assert next(rs)['name'] == 'potatoes'

    # syntax mix
    rs = q(['carrots']) * 'tomatoes' / r
    assert next(rs)['name'] == 'potatoes'

def casting(q, tk):
    r = f"""
        SELECT * FROM vegetables ORDER BY name
    """

    ns = q(
        cast = lambda r: r['name'].capitalize(),
        aslist = True,
    ) / r
    assert ns == ['Carrots', 'Potatoes', 'Tomatoes'], f'ns={ns}'

    class Veg:
        def __init__(self, row):
            self.id = row['id']
            self.name = row['name']

    ns = q(aslist=True, cast=Veg) / r
    assert ns[0].name == 'carrots'
    assert ns[1].name == 'potatoes'
    assert ns[2].name == 'tomatoes'

    # cast function compositions

    vegToName = lambda veg: veg.name
    f1 = lambda s: f'{s}_f1'
    f2 = lambda s: f'{s}_f2'
    for i, ns in enumerate((
        q / f1 / f2 / vegToName / Veg / r,
        q(
            cmpst_cast = (f1, f2, vegToName, Veg),
        ) / r,
        q(
            cast = Veg,
            cmpst_cast = (f1, f2, vegToName),
        ) / r,
        q(
            cast = Veg, carg = (),
            cmpst_cast = (f1, f2, vegToName),
        ) / r,
    )):
        ns = list(ns)
        assert tuple(ns) == (
            'carrots_f2_f1', 'potatoes_f2_f1', 'tomatoes_f2_f1'
        ), f'ns = {ns}'

def subscripts(q, tk):
    r = "SELECT * FROM vegetables ORDER BY name"
    ns = q(0) / r
    assert ns['name'] == 'carrots'

    ns = q[0] / r
    assert ns['name'] == 'carrots'

    ns = q[-1] / r
    assert ns['name'] == 'tomatoes'

    n = q[0]['name'] / r
    assert n == 'carrots'

    ns = q(cast=lambda row: row['name'])[0:2]
    assert ns == ('carrots', 'potatoes')

    ns = q(cast=lambda row: row['name'])[slice(1,3)]
    assert ns == ('potatoes', 'tomatoes')


with TestKitDB() as tk:
    for DBCls in (
        #Database_sqlite,  # TODO enable
        Database_mysql,
    ):
        q = tk.connect(DBCls=DBCls)
        populate(q, tk)

        # TODO uncomment the other funcs
        #general(q, tk)
        #placeholders(q, tk)
        casting(q, tk)
        #subscripts(q, tk)
