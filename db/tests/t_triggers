#!/usr/bin/python3
try:from pathlib import Path as P;R=P.resolve;E=P.exists; F = R(P(__file__));\
    L = lambda p: p / 'cfg.py'; from handyPyUtil import A; exec(A)
except: O=open(R(next(filter(E,map(L,F.parents))))); exec(O.read()); O.close()

import sys
import os
from pathlib import Path

from . import TestKitDB
from ..Database import DBTYPES
from .. import Database_mysql, Database_sqlite

from math import isclose

from ..TableRow import TableRow
from ..exceptions import *


N_RECORDS = 10


TableData = {}   # format:   {Id: dict_of_corr_values}
for Id in range(1, N_RECORDS + 1):
    n, x, s = Id ** 2, Id ** 0.5, f'str_{Id}'
    cvs = {'n': n, 'x': x, 's': s}
    TableData[Id] = cvs


class MyTableRow(TableRow):
    _tableName = 'my_table_row'
    _columnDefs = {
        'id': {
            DBTYPES.sqlite: 'INTEGER NOT NULL PRIMARY KEY',
            DBTYPES.mysql: 'INTEGER UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT',
        },
        'n': {
            DBTYPES.sqlite: 'INTEGER NOT NULL DEFAULT 0',
            DBTYPES.mysql: 'INTEGER NOT NULL DEFAULT 0',
        },
        'x': {
            DBTYPES.sqlite: 'FLOAT NOT NULL DEFAULT 0.',
            DBTYPES.mysql: 'FLOAT(53) NOT NULL DEFAULT 0.',
        },
        's': {
            DBTYPES.sqlite: 'VARCHAR(14) NOT NULL',
            DBTYPES.mysql: 'VARCHAR(14) NOT NULL',
        },
    }

    @classmethod
    def _beforeInsert(Cls, bo, trgData):
        bo.record('beforeInsert', trgData)

    @classmethod
    def _beforeUpdate(Cls, bo, trgData):
        bo.record('beforeUpdate', trgData)

    @classmethod
    def _beforeDelete(Cls, bo, trgData):
        bo.record('beforeDelete', trgData)

    @classmethod
    def _afterInsert(Cls, bo, trgData):
        bo.record('afterInsert', trgData)

    @classmethod
    def _afterUpdate(Cls, bo, trgData):
        bo.record('afterUpdate', trgData)

    @classmethod
    def _afterDelete(Cls, bo, trgData):
        bo.record('afterDelete', trgData)


class MyTableRow2(MyTableRow):
    _tableName = 'my_table_row2'

class MyTableRow3(MyTableRow):
    _tableName = 'my_table_row3'


classes = (MyTableRow, MyTableRow2, MyTableRow3)


def chkAgainstOriginalData(Id, mtr):
    cvs = TableData[Id]
    assert mtr.n == cvs['n']
    assert isclose(mtr.x, cvs['x']), f"x={mtr.x} but should be {cvs['x']}"
    assert mtr.s == cvs['s']

def chkAllTablesAgainstOriginalData(tk, q):
    for Cls in classes:
        for mtr in getAllRecords(tk, q, Cls):
            chkAgainstOriginalData(mtr.id, mtr)


def idSearchFails(qq, Id):
    fails = False
    try:
        MyTableRow(qq, _fromId=Id)
    except ExcRecordNotFound:
        fails = True
    return fails

def getNRecords(q):
    return q[0]['n'] / f'SELECT count(id) as n FROM {MyTableRow._tableName}'

def populate(tk, q):
    for Cls in (MyTableRow, MyTableRow2, MyTableRow3):
        q.createTable(Cls)
        for Id in range(1, N_RECORDS + 1):
            cvs = TableData[Id]
            mtr = Cls(q, **cvs)
            mtr._save()

def getAllRecords(tk, q, Cls):
    return q / Cls / f"SELECT * FROM {Cls._tableName} ORDER BY id"

def allTriggersExist(tk, q, tbl):
    allExist = True
    for timing in ('BEFORE', 'AFTER'):
        for evt in ('INSERT', 'UPDATE', 'DELETE'):
            trgn = f'trg_{tbl}_{timing}_{evt}'

            r = None
            if q.dbtype == DBTYPES.sqlite:
                r = f"""
                    SELECT name
                    FROM sqlite_master
                    WHERE
                        type = 'trigger' and
                        name = %(trgn)s  and
                        tbl_name = %(tbl)s and
                        sql like '%%' || %(timing)s || '%%' || %(evt)s || '%%'
                """
            elif q.dbtype == DBTYPES.mysql:
                r = f"""
                    SELECT trigger_name
                    FROM information_schema.triggers
                    WHERE
                        trigger_name = %(trgn)s  and
                        event_object_table = %(tbl)s and
                        action_timing = %(timing)s and
                        event_manipulation = %(evt)s
                """
            else: raise Exception(f'unsupported DB')

            rs = q(trgn=trgn, tbl=tbl, timing=timing, evt=evt, aslist=True) / r
            if not rs:
                allExist = False
                #tk.logger.debug(f'trigger {trgn} does not exist')

    return allExist


def installTriggers(tk, q):
    for Cls in (MyTableRow, MyTableRow2):
        assert not allTriggersExist(tk, q, Cls._tableName)
        q.triggerManager.connectCallbacks(Cls)
        chkAllTablesAgainstOriginalData(tk ,q)
        assert allTriggersExist(tk, q, Cls._tableName)

    # callbacks for my_table_row3 which is connected to triggers by table name

    def beforeInsert(bo, trgData): bo.record('beforeInsert', trgData)
    def afterInsert(bo, trgData): bo.record('afterInsert', trgData)
    def beforeUpdate(bo, trgData): bo.record('beforeUpdate', trgData)
    def afterUpdate(bo, trgData): bo.record('afterUpdate', trgData)
    def beforeDelete(bo, trgData): bo.record('beforeDelete', trgData)
    def afterDelete(bo, trgData): bo.record('afterDelet', trgData)

    assert not allTriggersExist(tk, q, MyTableRow3._tableName)
    q.triggerManager.connectCallbacks(MyTableRow3._tableName,
        beforeInsert = beforeInsert, afterInsert = afterInsert,
        beforeUpdate = beforeUpdate, afterUpdate = afterUpdate,
        beforeDelete = beforeDelete, afterDelete = afterDelete,
    )
    chkAllTablesAgainstOriginalData(tk, q)
    assert allTriggersExist(tk, q, MyTableRow3._tableName)

    tk.logger.debug(f'finished trigger installation')

def chkTriggers(tk, q, bo):
    assert len(bo.calls) == 0

    orig_mtrs = {
        Cls: {mtr.id: mtr for mtr in getAllRecords(tk, q, Cls)}
            for Cls in classes
    }

    for clind, Cls in enumerate(classes):
        for Id in range(1, len(orig_mtrs[Cls])+1):
            r0 = Cls(bo, _fromId=Id)
            q(commit=False, Id=Id) / f"""
                UPDATE {Cls._tableName} SET n = n + 1, x = x + 1,
                    s = {
                        "s || 'z'" if q.dbtype == DBTYPES.sqlite else "concat(s, 'z')"
                    }
                WHERE id = %(Id)s
            """
            r1 = MyTableRow(bo, _fromId=Id)
            assert r0._same(orig_mtrs[Cls][Id])
            assert not r0._same(r1)

            assert len(bo.calls) == 2 * N_RECORDS * clind + 2 * Id, f'len(bo.calls) = {len(bo.calls)}; Id = {Id}'
            cbn, trgData = (
                bo.calls[-2][k]
                    for k in ('cbn', 'trgData')
            )
            assert cbn == 'beforeUpdate'

            rOld, rNew = map(
                lambda r: MyTableRow(bo, _fromRow=r), (trgData['OLD'], trgData['NEW'])
            )
            assert r0._same(rOld)
            assert r1._same(rNew)

            assert r0.n + 1 == r1.n
            assert isclose(r0.x + 1, r1.x)
            assert r0.s + 'z' == r1.s

        
class BindObject:
    def __init__(self):
        self.calls = []  # format:  [{'cbn': '...', 'trgData': {...}}, ...]

    def record(self, cbn, trgData):
        self.calls.append({'cbn': cbn, 'trgData': trgData})


with TestKitDB() as tk:
    for DBCls in (
        Database_sqlite,
        Database_mysql,
    ):
        tk.logger.debug(f'starting the test case of {DBCls}')
        bo = BindObject()

        q = tk.connect(DBCls=DBCls, bindObject=bo)
        bo.q = q
        tk.logger.debug(f'connected to the {q.dbtype} DB')
        
        populate(tk, q)
        installTriggers(tk, q)
        chkTriggers(tk, q, bo)
        tk.logger.debug(f'finished the test case of {DBCls}')
